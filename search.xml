<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/05/hello-world/"/>
      <url>/2022/03/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01.列表</title>
      <link href="//pages/2270e1/"/>
      <url>//pages/2270e1/</url>
      
        <content type="html"><![CDATA[<h2 id="01-列表常用方法"><a href="#01-列表常用方法" class="headerlink" title="01.列表常用方法"></a>01.列表常用方法</h2><h3 id="1-1-append"><a href="#1-1-append" class="headerlink" title="1.1 append"></a>1.1 append</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. append用于在列表末尾追加新的对象</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.append(<span class="number">4</span>)                          <span class="comment">#the result ： [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="1-2-count"><a href="#1-2-count" class="headerlink" title="1.2 count"></a>1.2 count</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2. count方法统计某个元素在列表中出现的次数</span></span><br><span class="line">a = [<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a.count(<span class="string">&#x27;aa&#x27;</span>))                 <span class="comment">#the result ： 3</span></span><br></pre></td></tr></table></figure><h3 id="1-3-extend"><a href="#1-3-extend" class="headerlink" title="1.3 extend"></a>1.3 extend</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#3. extend方法可以在列表的末尾一次性追加另一个序列中的多个值</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.extend(b)                          <span class="comment">#the result ：[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h3 id="1-4-index"><a href="#1-4-index" class="headerlink" title="1.4 index"></a>1.4 index</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#4. index函数用于从列表中找出某个值第一个匹配项的索引位置</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(a.index(<span class="number">1</span>))                   <span class="comment">#the result ： 0</span></span><br></pre></td></tr></table></figure><h3 id="1-5-insert"><a href="#1-5-insert" class="headerlink" title="1.5 insert"></a>1.5 insert</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#5. insert方法用于将对象插入到列表中</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.insert(<span class="number">0</span>,<span class="string">&#x27;aa&#x27;</span>)            <span class="comment">#the result : [&#x27;aa&#x27;, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="1-6-pop"><a href="#1-6-pop" class="headerlink" title="1.6 pop"></a>1.6 pop</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#6. pop方法会移除列表中的一个元素（默认是最后一个），并且返回该元素的值</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.pop()                             <span class="comment">#the result ： [1, 2]</span></span><br><span class="line">a.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="1-7-remove"><a href="#1-7-remove" class="headerlink" title="1.7 remove"></a>1.7 remove</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#7. remove方法用于移除列表中某个值的第一个匹配项</span></span><br><span class="line">a = [<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>]</span><br><span class="line">a.remove(<span class="string">&#x27;aa&#x27;</span>)                      <span class="comment">#the result ： [&#x27;bb&#x27;, &#x27;cc&#x27;, &#x27;aa&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="1-8-reverse"><a href="#1-8-reverse" class="headerlink" title="1.8 reverse"></a>1.8 reverse</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#8. reverse方法将列表中的元素反向存放</span></span><br><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">a.reverse()                         <span class="comment">#the result ： [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="1-9-sort"><a href="#1-9-sort" class="headerlink" title="1.9 sort"></a>1.9 sort</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#9. sort方法用于在原位置对列表进行排序，意味着改变原来的列表，让其中的元素按一定顺序排列</span></span><br><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.sort()                           <span class="comment">#the result ：[1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="1-10-enumerate"><a href="#1-10-enumerate" class="headerlink" title="1.10 enumerate"></a>1.10 enumerate</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>]</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(li, <span class="number">1</span>):  <span class="comment"># 1.代表 k 从哪个数字开始</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 11</span></span><br><span class="line"><span class="string">2 22</span></span><br><span class="line"><span class="string">3 33</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-11-range和xrange"><a href="#1-11-range和xrange" class="headerlink" title="1.11 range和xrange"></a>1.11 range和xrange</h3><ul><li><p>指定范围，生成指定的数字</p></li><li><p>注：python3中的range类似python2中的xrange，比如a &#x3D; range(1,4) : a返回的不是列表对象而是一个可迭代对象（&lt;class ‘range’&gt;）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、range根据start与stop指定的范围以及step设定的步长，生成一个序列：range([start,] stop[, step])</span></span><br><span class="line"><span class="comment">#2、xrange 用法与 range 完全相同，所不同的是生成的不是一个list对象，而是一个生成器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h3 id="1-12-列表去空"><a href="#1-12-列表去空" class="headerlink" title="1.12 列表去空"></a>1.12 列表去空</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 法1：</span></span><br><span class="line"><span class="built_in">filter</span>(<span class="literal">None</span>, your_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2：</span></span><br><span class="line"><span class="keyword">while</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">in</span> your_list:</span><br><span class="line">    your_list.remove(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法3：</span></span><br><span class="line">your_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> your_list <span class="keyword">if</span> x != <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="02-元祖"><a href="#02-元祖" class="headerlink" title="02.元祖"></a>02.元祖</h2><ul><li><strong>元组定义：</strong>元组和列表一样，也是一种序列，唯一的不同是元组不能修改。</li></ul><h3 id="2-1-创建元组"><a href="#2-1-创建元组" class="headerlink" title="2.1 创建元组"></a>2.1 创建元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 创建元组</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">#2. 将列表转换成元组</span></span><br><span class="line"><span class="built_in">tuple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])                                    <span class="comment">#the result ： (1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure><h3 id="2-2-列表和元组常用函数"><a href="#2-2-列表和元组常用函数" class="headerlink" title="2.2 列表和元组常用函数"></a>2.2 列表和元组常用函数</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>com(x,y)</td><td>比较两个值</td></tr><tr><td>len(seq)</td><td>返回序列的长度</td></tr><tr><td>list(seq)</td><td>把序列转换成列表</td></tr><tr><td>max(args)</td><td>返回序列或者参数集合中得最大值</td></tr><tr><td>min(args)</td><td>返回序列或者参数集合中的最小值</td></tr><tr><td>reversed(seq)</td><td>对序列进行反向迭代</td></tr><tr><td>sorted(seq)</td><td>返回已经排列的包含seq 所有元素的列表</td></tr><tr><td>tuple(seq)</td><td>把序列转换成元组</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.字符串</title>
      <link href="//pages/50a8ce/"/>
      <url>//pages/50a8ce/</url>
      
        <content type="html"><![CDATA[<h2 id="01-字符串常用方法"><a href="#01-字符串常用方法" class="headerlink" title="01.字符串常用方法"></a>01.字符串常用方法</h2><h3 id="1-1-find方法"><a href="#1-1-find方法" class="headerlink" title="1.1 find方法"></a>1.1 <code>find</code>方法</h3><ul><li><code>作用：</code>find方法可以在一个较长的字符串中查找子串，他返回子串所在位置的最左端索引，如果没有找到则返回-1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;abcdefghijk&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.find(<span class="string">&#x27;abc&#x27;</span>))                         <span class="comment">#the result ： 0</span></span><br><span class="line"><span class="built_in">print</span>(a.find(<span class="string">&#x27;abc&#x27;</span>,<span class="number">10</span>,<span class="number">100</span>))                    <span class="comment">#the result ： 11  指定查找的起始和结束查找位置</span></span><br></pre></td></tr></table></figure><h3 id="1-2-join方法"><a href="#1-2-join方法" class="headerlink" title="1.2 join方法"></a>1.2 <code>join</code>方法</h3><ul><li><code>作用：</code>join方法是非常重要的字符串方法，他是split方法的逆方法，用来连接序列中的元素，并且需要被连接的元素都必须是字符串。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>.join(a))                                    <span class="comment">#the result ： 1+2+3</span></span><br></pre></td></tr></table></figure><h3 id="1-3-split方法"><a href="#1-3-split方法" class="headerlink" title="1.3 split方法"></a>1.3 <code>split</code>方法</h3><ul><li><code>作用：</code>这是一个非常重要的字符串，它是join的逆方法，用来将字符串分割成序列</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">print</span>(<span class="string">&#x27;1+2+3+4&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;+&#x27;</span>))                            #the result ： [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="1-4-strip"><a href="#1-4-strip" class="headerlink" title="1.4 strip"></a>1.4 strip</h3><ul><li><code>作用：</code>strip 方法返回去除首位空格（不包括内部）的字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   test   test    &quot;</span>.strip())                <span class="comment">#the result ：“test   test”</span></span><br></pre></td></tr></table></figure><h3 id="1-5-replace"><a href="#1-5-replace" class="headerlink" title="1.5 replace"></a>1.5 replace</h3><ul><li><code>作用：</code>replace方法返回某字符串所有匹配项均被替换之后得到字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is a test&quot;</span>.replace(<span class="string">&#x27;is&#x27;</span>,<span class="string">&#x27;is_test&#x27;</span>))     <span class="comment">#the result ： This_test is_test a test</span></span><br></pre></td></tr></table></figure><h3 id="1-6-首字母大写"><a href="#1-6-首字母大写" class="headerlink" title="1.6 首字母大写"></a>1.6 首字母大写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;aBdkndfkFFD&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.capitalize()</span><br><span class="line"><span class="string">&#x27;Abdkndfkffd&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-7-Pinyin-模块，将汉字转换成拼音"><a href="#1-7-Pinyin-模块，将汉字转换成拼音" class="headerlink" title="1.7 Pinyin 模块，将汉字转换成拼音"></a>1.7 Pinyin 模块，将汉字转换成拼音</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> xpinyin <span class="keyword">import</span> Pinyin</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = Pinyin()</span><br><span class="line">    fullname = raw_input(<span class="string">&#x27;name：&#x27;</span>).strip()</span><br><span class="line">    fullname = fullname.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> fullname</span><br><span class="line">    xin = fullname[<span class="number">0</span>]</span><br><span class="line">    ming = fullname[<span class="number">1</span>:]</span><br><span class="line">    name = ming + <span class="string">&#x27;.&#x27;</span> + xin</span><br><span class="line">    username = p.get_pinyin(name, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> username</span><br><span class="line">    <span class="built_in">print</span> username + <span class="string">&#x27;@yiducloud.cn&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="02-字符串格式化"><a href="#02-字符串格式化" class="headerlink" title="02.字符串格式化"></a>02.字符串格式化</h2><h3 id="2-1-使用百分号（-）字符串格式化"><a href="#2-1-使用百分号（-）字符串格式化" class="headerlink" title="2.1 使用百分号（%）字符串格式化"></a>2.1 使用百分号（%）字符串格式化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d to hex is %x&quot;</span> %(num, num))        <span class="comment">#100 to hex is 64</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d to hex is %#x&quot;</span> %(num, num))       <span class="comment">#100 to hex is 0x64</span></span><br></pre></td></tr></table></figure><h3 id="2-2-使用format字符串格式化"><a href="#2-2-使用format字符串格式化" class="headerlink" title="2.2 使用format字符串格式化"></a>2.2 使用format字符串格式化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 位置参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0&#125; is &#123;1&#125; years old&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">28</span>))            <span class="comment">#tom is 28 years old</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; years old&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">28</span>))             <span class="comment">#tom is 28 years old</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hi, &#123;0&#125;! &#123;0&#125; is &#123;1&#125; years old&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">28</span>))      <span class="comment">#Hi, tom! tom is 28 years old</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 关键字参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;name&#125; is &#123;age&#125; years old&quot;</span>.<span class="built_in">format</span>(name = <span class="string">&quot;tom&quot;</span>, age = <span class="number">28</span>))    <span class="comment">#tom is 28 years old</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 下标参数</span></span><br><span class="line">li = [<span class="string">&quot;tom&quot;</span>, <span class="number">28</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0[0]&#125; is &#123;0[1]&#125; years old&quot;</span>.<span class="built_in">format</span>(li))          <span class="comment">#tom is 28 years old</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.集合</title>
      <link href="//pages/0316d2/"/>
      <url>//pages/0316d2/</url>
      
        <content type="html"><![CDATA[<h2 id="01-集合"><a href="#01-集合" class="headerlink" title="01.集合"></a>01.集合</h2><ul><li>集合作用<ul><li><p>去重</p></li><li><p>取两个列表的交集</p></li><li><p>取两个列表的并集</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">list_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="comment">#1、去重(去除list_1中重复元素1,2)</span></span><br><span class="line">list_1 = <span class="built_in">set</span>(list_1)                                <span class="comment">#去重： &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="built_in">print</span>(list_1)</span><br><span class="line">list_2 = <span class="built_in">set</span>([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、交集（在list_1和list_2中都有的元素4,5）</span></span><br><span class="line"><span class="built_in">print</span>(list_1.intersection(list_2))                      <span class="comment">#交集： &#123;4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、并集（在list_1和list_2中的元素全部打印出来，重复元素仅打印一次）</span></span><br><span class="line"><span class="built_in">print</span>(list_1.union(list_2))                          <span class="comment">#并集： &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4、差集</span></span><br><span class="line"><span class="built_in">print</span>(list_1.difference(list_2))                        <span class="comment">#差集：在list_1中有在list_2中没有：   &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="built_in">print</span>(list_2.difference(list_1))                        <span class="comment">#差集：在list_1中有在list_2中没有：   &#123;8, 6, 7&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5、子集</span></span><br><span class="line"><span class="built_in">print</span>(list_1.issubset(list_2))                          <span class="comment">#子集：    False    List_1中的元素是否全部在list2中</span></span><br><span class="line"><span class="comment">#6、父集</span></span><br><span class="line"><span class="built_in">print</span>(list_1.issuperset(list_2))                        <span class="comment">#父集：    False    List_1中是否包含list_2中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7、交集</span></span><br><span class="line"><span class="built_in">print</span>(list_1 &amp; list_2)                                  <span class="comment">#交集    &#123;4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8、union并集</span></span><br><span class="line"><span class="built_in">print</span>(list_1 | list_2)                                  <span class="comment">#并集：  &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#9、difference差集</span></span><br><span class="line"><span class="built_in">print</span>(list_1 - list_2)                                  <span class="comment">#差集：    &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#10、在集合中添加一个元素999</span></span><br><span class="line">list_1.add(<span class="number">999</span>)</span><br><span class="line"><span class="built_in">print</span>(list_1)                                       <span class="comment">#Add()方法：          &#123;1, 2, 3, 4, 5, 999&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#11、删除集合中任意一个元素不会打印删除的值</span></span><br><span class="line">list_1.pop()                                        <span class="comment">#Pop()方法：            无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#12、discard删除集合中的指定元素，如过没有则返回None</span></span><br><span class="line"><span class="built_in">print</span>(list_1.discard(<span class="string">&quot;ddd&quot;</span>))                            <span class="comment">#Discard()方法：   删除指定的值，没有返回None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.进程</title>
      <link href="//pages/f8baa8/"/>
      <url>//pages/f8baa8/</url>
      
        <content type="html"><![CDATA[<h2 id="01-进程"><a href="#01-进程" class="headerlink" title="01.进程"></a>01.进程</h2><h3 id="1-1-什么是进程？"><a href="#1-1-什么是进程？" class="headerlink" title="1.1 什么是进程？"></a>1.1 什么是进程？</h3><ul><li><code>1.进程是资源分配的最小单位（ 内存、cpu、网络、io）</code></li><li><code>2.一个运行起来的程序就是一个进程</code><ul><li>什么是程序（<code>程序是我们存储在硬盘里的代码</code>）<ul><li>硬盘（256G）、内存条（8G）</li><li>当我们双击图标，打开程序的时候，实际上就是通过I&#x2F;O操作（读写），硬盘中的代码读取到内存条里</li></ul></li><li>内存条就是我们所指的资源（程序分配了内存资源，就变成了进程）</li><li>CPU分时<ul><li>CPU比你的手速快多了，分时处理每个线程，但是由于太快然你觉得每个线程都是独占cpu</li><li>cpu是计算，只有时间片到了，获取cpu，线程真正执行</li><li>当你想使用 网络、磁盘等资源的时候，需要cpu的调度</li></ul></li></ul></li><li><code>3.进程具有独立的内存空间，所以没有办法相互通信</code></li></ul><h3 id="1-2-进程如何通信"><a href="#1-2-进程如何通信" class="headerlink" title="1.2 进程如何通信?"></a>1.2 进程如何通信?</h3><ul><li>同一程序下进程通信<ul><li>进程queue(父子进程通信)</li><li>pipe（同一程序下两个进程通信）</li><li>managers（同一程序下多个进程通信）</li></ul></li><li>Java项目和python项目如何通信<ul><li>RabbitMQ、redis等（不同程序间通信）</li></ul></li></ul><h3 id="1-3-为什么需要进程池？"><a href="#1-3-为什么需要进程池？" class="headerlink" title="1.3 为什么需要进程池？"></a>1.3 为什么需要进程池？</h3><ul><li>一次性开启指定数量的进程</li><li>如果有十个进程，有一百个任务，一次可以处理多少个（一次性只能处理十个）</li><li>防止进程开启数量过多导致服务器压力过大</li><li>进程池中有两个方法：<ul><li><code>1）apply</code>： 多个进程异步执行，一个一个的执行</li><li><code>2）apply_async</code>： 多个进程同步执行，同时执行多个进程</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Process,Pool</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">i</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the process&quot;</span>,os.getpid()) <span class="comment">#打印子进程的pid</span></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;exec done:&#x27;</span>,arg,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(<span class="number">3</span>)                      <span class="comment">#进程池最多允许5个进程放入进程池</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程pid：&quot;</span>,os.getpid())     <span class="comment">#打印父进程的pid</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment">#用法1 callback作用是指定只有当Foo运行结束后就执行callback调用的函数,父进程调用的callback函数</span></span><br><span class="line">        pool.apply_async(func=foo, args=(i,),callback=call)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#用法2 串行 启动进程不在用Process而是直接用pool.apply()</span></span><br><span class="line">        <span class="comment"># pool.apply(func=foo, args=(i,))</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    pool.close()    <span class="comment">#关闭pool</span></span><br><span class="line">    pool.join()     <span class="comment">#进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span></span><br></pre></td></tr></table></figure><h3 id="1-4-僵尸进程"><a href="#1-4-僵尸进程" class="headerlink" title="1.4 僵尸进程"></a>1.4 僵尸进程</h3><ul><li><p><code>1）僵尸进程定义</code></p><ul><li><ol><li>僵尸进程产生的原因就是父进程产生子进程后，子进程先于父进程退出</li></ol></li><li><ol start="2"><li>但是父进程由于种种原因，并没有处理子进程发送的退出信号，那么这个子进程就会成为僵尸进程。</li></ol></li></ul></li><li><p><code>2）用python写一个僵尸进程</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> os, sys, time</span><br><span class="line"><span class="comment">#产生子进程</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="comment">#子进程退出</span></span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#父进程休息30秒</span></span><br><span class="line">time.sleep(<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 先产生一个子进程，子进程退出，父进程休息30秒,那就会产生一个僵尸进程</span></span><br></pre></td></tr></table></figure><ul><li><p><code>ps -ef| grep defunct</code> 在linux下查看僵尸进程</p><ul><li>&#96;&#96;&#96;python<br>[root@linux-node4 ~]# ps -ef| grep defunct<br>root     110401  96083  0 19:11 pts&#x2F;2    00:00:00 python defunct.py<br>root     110402 110401  0 19:11 pts&#x2F;2    00:00:00 [python] <defunct><br>root     110406  96105  0 19:11 pts&#x2F;3    00:00:00 grep –color&#x3D;auto defunct<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 1.5 Python中使用过的进程模块？</span><br><span class="line"></span><br><span class="line">#### 1.5.1 multiprocessing</span><br><span class="line"></span><br><span class="line">- `multiprocessing`是一个使用类似于线程模块的API支持产生进程的包。 </span><br><span class="line">- 多处理包提供本地和远程并发，通过使用子进程而不是线程有效地侧向执行全局解释器锁。 </span><br><span class="line">- 因此，多处理模块允许程序员充分利用给定机器上的多个处理器。 它可以在Unix和Windows上运行。</span><br><span class="line">- ``进程池抓取页面``</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line">def fetch_request(url):</span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    print(result.text)</span><br><span class="line"></span><br><span class="line">def call(arg):</span><br><span class="line">    print(&#x27;--&gt;exec done:&#x27;,&quot;测试进程池执行后回调功能&quot;)</span><br><span class="line"></span><br><span class="line">url_list = [</span><br><span class="line">    &#x27;https://www.baidu.com&#x27;,</span><br><span class="line">    &#x27;https://www.google.com/&#x27;,         #google页面会卡住，知道页面超时后这个进程才结束</span><br><span class="line">    &#x27;http://dig.chouti.com/&#x27;,          #chouti页面内容会直接返回，不会等待Google页面的返回</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pool = Pool(10)        # 创建线程池</span><br><span class="line">    for url in url_list:</span><br><span class="line">        #用法1 callback作用是指定只有当Foo运行结束后就执行callback调用的函数,父进程调用的callback函数</span><br><span class="line">        pool.apply_async(func=fetch_request, args=(url,),callback=call)</span><br><span class="line">    print(&#x27;end&#x27;)</span><br><span class="line">    pool.close()    #关闭pool</span><br><span class="line">    pool.join()     #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="1-5-2-concurrent-futures"><a href="#1-5-2-concurrent-futures" class="headerlink" title="1.5.2 concurrent.futures"></a>1.5.2 concurrent.futures</h4><ul><li><p><code>1、简介</code> <a href="https://docs.python.org/3/library/concurrent.futures.html">参考官网</a></p><ul><li>1、Python标准库为我们提供了threading和multiprocessing模块编写相应的多线程&#x2F;多进程代码</li><li>2、但是当项目达到一定的规模，频繁创建&#x2F;销毁进程或者线程是非常消耗资源的，这个时候我们就要编写自己的线程池&#x2F;进程池，以空间换时间。</li><li>3、但从Python3.2开始，标准库为我们提供了concurrent.futures模块，它提供了ThreadPoolExecutor和ProcessPoolExecutor两个类，</li><li>4、实现了对threading和multiprocessing的进一步抽象，对编写线程池&#x2F;进程池提供了直接的支持。</li></ul></li><li><p><code>2、Executor和Future</code></p><ul><li><code>1. Executor</code><br> -  concurrent.futures模块的基础是Exectuor，Executor是一个抽象类，它不能被直接使用。</li></ul><pre><code> -  但是它提供的两个子类ThreadPoolExecutor和ProcessPoolExecutor却是非常有用  -  我们可以将相应的tasks直接放入线程池/进程池，不需要维护Queue来操心死锁的问题，线程池/进程池会自动帮我们调度。 </code></pre><ul><li><code>2. Future</code><br> -  Future你可以把它理解为一个在未来完成的操作，这是异步编程的基础，</li></ul><pre><code> -  传统编程模式下比如我们操作queue.get的时候，在等待返回结果之前会产生阻塞，cpu不能让出来做其他事情 - 而Future的引入帮助我们在等待的这段时间可以完成其他的操作。</code></pre></li><li><p>3、concurrent.futures.ProcessPoolExecutor 抓取网页</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_request</span>(<span class="params">url</span>):</span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(result.text)</span><br><span class="line"></span><br><span class="line">url_list = [</span><br><span class="line">    <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://www.google.com/&#x27;</span>,         <span class="comment">#google页面会卡住，知道页面超时后这个进程才结束</span></span><br><span class="line">    <span class="string">&#x27;http://dig.chouti.com/&#x27;</span>,          <span class="comment">#chouti页面内容会直接返回，不会等待Google页面的返回</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">10</span>)        <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">        pool.submit(fetch_request,url)    <span class="comment"># 去线程池中获取一个进程，进程去执行fetch_request方法</span></span><br><span class="line">    pool.shutdown(wait = <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># shutdown相当于一个开关，它会读取程序中所设定的进程总数，直至每开启一个进程，它读取设定的总数就会减一，直至为0时便会打印主线程</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.协程</title>
      <link href="//pages/7cc201/"/>
      <url>//pages/7cc201/</url>
      
        <content type="html"><![CDATA[<h2 id="01-协程"><a href="#01-协程" class="headerlink" title="01.协程"></a>01.协程</h2><p><a href="https://www.cnblogs.com/xiaonq/p/7905347.html#i4">https://www.cnblogs.com/xiaonq/p/7905347.html#i4</a></p><h3 id="1-1-什么是协程"><a href="#1-1-什么是协程" class="headerlink" title="1.1 什么是协程"></a>1.1 什么是协程</h3><ul><li>1）<code>协程微线程，纤程，本质是一个单线程</code></li><li>2）<code>协程能在单线程处理高并发，因为遇到IO自动切换</code><ul><li><code>线程遇到I/O操作会等待、阻塞</code>，<code>协程遇到I/O会自动切换</code>（剩下的只有CPU操作）</li><li>线程的状态<code>保存在CPU的寄存器和栈里而协程拥有自己的空间，所以无需上下文切换的开销，所以快</code></li></ul></li><li>3）<code>为甚么协程能够遇到I/O自动切换</code><ul><li>greenlet是C语言写的一个模块，遇到IO手动切换</li><li>协程有一个gevent模块(封装了greenlet模块)，遇到I&#x2F;O自动切换</li></ul></li><li>4）协程拥有自己的空间，所以无需上下文切换的开销</li></ul><h3 id="1-2-协程优缺点"><a href="#1-2-协程优缺点" class="headerlink" title="1.2 协程优缺点"></a>1.2 协程优缺点</h3><ul><li><p><code>协程缺点</code></p><ul><li>无法利用多核资源：<code>协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上</code>,协程需要和进程配合才能运行在多CPU上</li><li><code>协程如果阻塞掉，整个程序都阻塞</code></li></ul></li><li><p><code>协程最大的优点</code></p><ul><li>不仅是处理高并发（单线程下处理高并发）</li><li>特别节省资源（协程本质是一个单线程，当然节省资源）<ul><li>500日活，用php写需要两百多态机器，但是golang只需要二十多太机器</li></ul></li></ul></li></ul><h3 id="1-3-协程遇到I-x2F-O切换，那活只谁干的？"><a href="#1-3-协程遇到I-x2F-O切换，那活只谁干的？" class="headerlink" title="1.3 协程遇到I&#x2F;O切换，那活只谁干的？"></a>1.3 协程遇到I&#x2F;O切换，那活只谁干的？</h3><ul><li><p>简单说法</p><ul><li>协程遇到I&#x2F;O后自动切换，但是会保持一个socket连接，交给系统内核去处理工作</li><li>epoll()就工作内核中，他维护了一个链表，来存放所有的socket连接</li><li>当内核处理完成后就会回调一个函数，以socket文件描述符为key，结果为value存放到字典中</li><li>此时这个列表还是在内核中，需要将这个字典拷贝到用户空间（用户进程中）</li></ul></li><li><p>本质</p><ul><li>1.<code>epoll()中内核则维护一个链表</code>，epoll_wait直接检查链表是不是空就知道是否有文件描述符准备好了。</li><li>2.在内核实现中epoll是根据每个sockfd上面的与设备驱动程序建立起来的回调函数实现的。</li><li>3.某个sockfd上的事件发生时，与它对应的回调函数就会被调用，来把这个sockfd加入链表，其他处于“空闲的”状态的则不会。</li><li>4.epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术，避免了复制大量文件描述符带来的开销</li><li>内存映射（mmap）：内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行I&#x2F;O操作</li></ul></li></ul><h3 id="1-4-Python中协程的模块"><a href="#1-4-Python中协程的模块" class="headerlink" title="1.4 Python中协程的模块"></a>1.4 Python中协程的模块</h3><ul><li>greenlet：遇到I&#x2F;O<code>手动切换</code>，是一个C模块</li><li>gevent：对greenlet封装，遇到I&#x2F;O<code>自动切换</code>（<code>借助C语言库greenlet</code>）</li><li>asyncio：和gevent一样，也是实现协程的一个模块（<code>python自己实现</code>）<ul><li><a href="https://www.cnblogs.com/xiaonq/p/12870204.html">https://www.cnblogs.com/xiaonq/p/12870204.html</a></li></ul></li></ul><h2 id="02-进程，线程，协程爬取页面"><a href="#02-进程，线程，协程爬取页面" class="headerlink" title="02.进程，线程，协程爬取页面"></a>02.进程，线程，协程爬取页面</h2><ul><li>特点：<ul><li><code>1.进程</code>：启用进程非常浪费资源</li><li><code>2.线程</code>：线程多，并且在阻塞过程中无法执行其他任务</li><li><code>3.协程</code>：gevent只用起一个线程，当请求发出去后gevent就不管,永远就只有一个线程工作，谁先回来先处理</li></ul></li></ul><h3 id="2-1-for循环"><a href="#2-1-for循环" class="headerlink" title="2.1 for循环"></a>2.1 for循环</h3><ul><li>第四：性能最差</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url_list = [</span><br><span class="line">    <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://dig.chouti.com/&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> <span class="attr">url_list</span>:</span><br><span class="line">    result = requests.<span class="title function_">get</span>(url)</span><br><span class="line">    <span class="title function_">print</span>(result.<span class="property">text</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-进程池"><a href="#2-2-进程池" class="headerlink" title="2.2 进程池"></a>2.2 进程池</h3><ul><li><code>缺点：</code>启用进程非常浪费资源</li></ul><h4 id="2-2-1-multiprocessing-Pool"><a href="#2-2-1-multiprocessing-Pool" class="headerlink" title="2.2.1 multiprocessing.Pool"></a>2.2.1 multiprocessing.Pool</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_request</span>(<span class="params">url</span>):</span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(result.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;exec done:&#x27;</span>,<span class="string">&quot;测试进程池执行后回调功能&quot;</span>)</span><br><span class="line"></span><br><span class="line">url_list = [</span><br><span class="line">    <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://www.google.com/&#x27;</span>,         <span class="comment">#google页面会卡住，知道页面超时后这个进程才结束</span></span><br><span class="line">    <span class="string">&#x27;http://dig.chouti.com/&#x27;</span>,          <span class="comment">#chouti页面内容会直接返回，不会等待Google页面的返回</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(<span class="number">10</span>)        <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">        <span class="comment">#用法1 callback作用是指定只有当Foo运行结束后就执行callback调用的函数,父进程调用的callback函数</span></span><br><span class="line">        pool.apply_async(func=fetch_request, args=(url,),callback=call)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    pool.close()    <span class="comment">#关闭pool</span></span><br><span class="line">    pool.join()     <span class="comment">#进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-ProcessPoolExecutor"><a href="#2-2-2-ProcessPoolExecutor" class="headerlink" title="2.2.2 ProcessPoolExecutor"></a>2.2.2 ProcessPoolExecutor</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_request</span>(<span class="params">url</span>):</span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(result.text)</span><br><span class="line"></span><br><span class="line">url_list = [</span><br><span class="line">    <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://www.google.com/&#x27;</span>,         <span class="comment">#google页面会卡住，知道页面超时后这个进程才结束</span></span><br><span class="line">    <span class="string">&#x27;http://dig.chouti.com/&#x27;</span>,          <span class="comment">#chouti页面内容会直接返回，不会等待Google页面的返回</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">10</span>)        <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">        pool.submit(fetch_request,url)    <span class="comment"># 去线程池中获取一个进程，进程去执行fetch_request方法</span></span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="2-3-线程池"><a href="#2-3-线程池" class="headerlink" title="2.3 线程池"></a>2.3 线程池</h3><ul><li><code>缺点：</code> 创建一个新线程将消耗大量的计算资源，并且在阻塞过程中无法执行其他任务。</li><li><code>例：</code> 比如线程池中10个线程同时去10个url获取数据，当数据还没来时这些线程全部都在等待，不做事。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_request</span>(<span class="params">url</span>):</span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(result.text)</span><br><span class="line"></span><br><span class="line">url_list = [</span><br><span class="line">    <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://www.google.com/&#x27;</span>,         <span class="comment">#google页面会卡住，知道页面超时后这个进程才结束</span></span><br><span class="line">    <span class="string">&#x27;http://dig.chouti.com/&#x27;</span>,          <span class="comment">#chouti页面内容会直接返回，不会等待Google页面的返回</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)            <span class="comment"># 创建一个线程池，最多开10个线程</span></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    pool.submit(fetch_request,url)       <span class="comment"># 去线程池中获取一个线程，线程去执行fetch_request方法</span></span><br><span class="line"></span><br><span class="line">pool.shutdown(<span class="literal">True</span>)                      <span class="comment"># 主线程自己关闭，让子线程自己拿任务执行</span></span><br></pre></td></tr></table></figure><h3 id="2-4-协程"><a href="#2-4-协程" class="headerlink" title="2.4 协程"></a>2.4 协程</h3><ul><li><code>特点 ：</code>gevent只用起一个线程，当请求发出去后gevent就不管,永远就只有一个线程工作，谁先回来先处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all(select=<span class="literal">False</span>)  <span class="comment"># 注意，这个导包顺序不要变</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些请求谁先回来就先处理谁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_async</span>(<span class="params">method, url, req_kwargs</span>):</span><br><span class="line">    response = requests.request(method=method, url=url, **req_kwargs)</span><br><span class="line">    <span class="built_in">print</span>(response.url, response.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ##### 发送请求 #####</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">&#x27;get&#x27;</span>, url=<span class="string">&#x27;https://www.baidu.com/&#x27;</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">&#x27;get&#x27;</span>, url=<span class="string">&#x27;https://www.google.com/&#x27;</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">&#x27;get&#x27;</span>, url=<span class="string">&#x27;https://github.com/&#x27;</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.字典</title>
      <link href="//pages/24f2db/"/>
      <url>//pages/24f2db/</url>
      
        <content type="html"><![CDATA[<h2 id="01-字典常用方法"><a href="#01-字典常用方法" class="headerlink" title="01.字典常用方法"></a>01.字典常用方法</h2><h3 id="1-1-clear"><a href="#1-1-clear" class="headerlink" title="1.1 clear"></a>1.1 clear</h3><ul><li><code>作用：</code>clear方法清除字典中所有的项，这是一个原地操作，所以无返回值（或则说返回None）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">&#x27;Tom&#x27;</span>]=<span class="number">8777</span>             <span class="comment"># 在字典中添加数据           </span></span><br><span class="line">d[<span class="string">&#x27;Jack&#x27;</span>]=<span class="number">9999</span>    </span><br><span class="line"><span class="built_in">print</span>(d)                 <span class="comment">#the result : &#123;&#x27;Jack&#x27;: 9999, &#x27;Tom&#x27;: 8777&#125;</span></span><br><span class="line">d.clear()</span><br><span class="line"><span class="built_in">print</span>(d)                <span class="comment">#the result : &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-copy"><a href="#1-2-copy" class="headerlink" title="1.2 copy"></a>1.2 copy</h3><ul><li><code>作用：</code>copy方法返回一个具有相同 ”键-值” 对的新字典，而不是副本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line">a = d.copy()</span><br><span class="line">a[<span class="string">&#x27;Tom&#x27;</span>] = <span class="string">&#x27;改变后的值&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)                        <span class="comment">#&#123;&#x27;Fly&#x27;: 6666, &#x27;Tom&#x27;: 8777&#125;</span></span><br><span class="line"><span class="built_in">print</span>(a)                        <span class="comment">#&#123;&#x27;Fly&#x27;: 6666, &#x27;Tom&#x27;: &#x27;改变后的值&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-fromkeys"><a href="#1-3-fromkeys" class="headerlink" title="1.3 fromkeys"></a>1.3 fromkeys</h3><ul><li><p><code>作用：</code>fromkeys方法使用给定的键建立新的字典，每个键都对应一个默认的值None。</p></li><li><p>首先建造一个空字典，然后调用它的fromkeys方法，建立另一个字典</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(&#123;&#125;.fromkeys([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]))         <span class="comment">#the result　：　&#123;&#x27;age&#x27;: None, &#x27;name&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-get"><a href="#1-4-get" class="headerlink" title="1.4 get"></a>1.4 get</h3><ul><li><code>作用：</code>get方法是个更宽松的访问字典项的方法，如果试图访问字典中不存在的项时不会报错仅会    返回：None</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;Tom&#x27;</span>))                              <span class="comment">#the result ：     8777</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;not_exist&#x27;</span>))                          <span class="comment">#the result ：     None</span></span><br></pre></td></tr></table></figure><h3 id="1-5-循环字典"><a href="#1-5-循环字典" class="headerlink" title="1.5 循环字典"></a>1.5 循环字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line"><span class="comment"># 方法1：</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line"><span class="comment"># 方法:3</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys():</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure><h3 id="1-6-pop"><a href="#1-6-pop" class="headerlink" title="1.6 pop"></a>1.6 pop</h3><ul><li><code>作用：</code>pop方法用于获得对应与给定键的值，然后将这个”键-值”对从字典中移除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line">v = d.pop(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(v)                    <span class="comment">#8777</span></span><br></pre></td></tr></table></figure><h3 id="1-7-setdefault"><a href="#1-7-setdefault" class="headerlink" title="1.7 setdefault"></a>1.7 setdefault</h3><ul><li>作用：setdefault方法在某种程度上类似于get方法，能够获得与给定键相关联的值</li><li>除此之外，setdefault还能在字典中不含有给定键的情况下设定相应的键值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line">d.setdefault(<span class="string">&#x27;Tom&#x27;</span>)                          <span class="comment">#the result ： 8777</span></span><br><span class="line"><span class="built_in">print</span>(d.setdefault(<span class="string">&#x27;Test&#x27;</span>))                     <span class="comment">#the result ： None</span></span><br><span class="line"><span class="built_in">print</span>(d)                                  <span class="comment">#&#123;&#x27;Fly&#x27;: 6666, &#x27;Jack&#x27;: 8888, &#x27;Tom&#x27;: 8777, &#x27;Test&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-8-update"><a href="#1-8-update" class="headerlink" title="1.8 update"></a>1.8 update</h3><ul><li><code>作用</code>：update方法可以利用一个字典项更新另一个字典，提供的字典中的项会被添加到旧的字典中，如有相同的键则会被覆盖</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line">a = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">110</span>,<span class="string">&#x27;Test&#x27;</span>:<span class="number">119</span>&#125;</span><br><span class="line">d.update(a)</span><br><span class="line"><span class="built_in">print</span>(d)                        <span class="comment">#the result ：&#123;&#x27;Fly&#x27;: 6666, &#x27;Test&#x27;: 119, &#x27;Jack&#x27;: 8888, &#x27;Tom&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-9-将两个列表组合成字典"><a href="#1-9-将两个列表组合成字典" class="headerlink" title="1.9 将两个列表组合成字典"></a>1.9 将两个列表组合成字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">#1、zip生成字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(keys,values)))                              <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"><span class="comment">#2、for循环推倒字典</span></span><br><span class="line"><span class="built_in">print</span>(&#123;keys[i]: values[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(keys))&#125;)              <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.线程</title>
      <link href="//pages/70eebd/"/>
      <url>//pages/70eebd/</url>
      
        <content type="html"><![CDATA[<h2 id="01-线程"><a href="#01-线程" class="headerlink" title="01.线程"></a>01.线程</h2><h3 id="1-1-什么是线程"><a href="#1-1-什么是线程" class="headerlink" title="1.1 什么是线程"></a>1.1 什么是线程</h3><ul><li>1）线程是操作系统调度的最小单位</li><li>2）线程是进程正真的执行者，是一些指令的集合（进程资源的拥有者）</li><li>3）同一个进程下的多个<code>线程共享内存空间</code>，数据直接访问（数据共享）</li><li>4）为了保证数据安全，必须使用<code>线程锁</code></li></ul><p><code>说明：</code>下面利用for循环同时启动50个线程并行执行，执行时间是3秒而不是所有线程执行时间的总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayhi</span>(<span class="params">num</span>): <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running on number:%s&quot;</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">&#x27;t-%s&#x27;</span>%i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="1-2-GIL锁和线程锁"><a href="#1-2-GIL锁和线程锁" class="headerlink" title="1.2 GIL锁和线程锁"></a>1.2 GIL锁和线程锁</h3><ul><li>GIL全局解释器锁<ul><li>在python全局解释器下，保证同一时间只有一个线程运行</li><li>防止多个线程都修改数据</li></ul></li><li>线程锁（互斥锁）<ul><li>GIL锁只能保证同一时间只能有一个线程对某个资源操作，但当上一个线程还未执行完毕时可能就会释放GIL，其他线程就可以操作了</li><li>线程锁本质把线程中的数据加了一把互斥锁<ul><li>加上线程锁之后所有其他线程，读都不能读这个数据</li></ul></li><li>有了GIL全局解释器锁为什么还需要线程锁<ul><li>因为cpu是分时使用的</li></ul></li></ul></li><li><code>在有GIL的情况下执行 count = count + 1 会出错原因解析，用线程锁解决方法</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1）第一步：count = 0   count初始值为0</span></span><br><span class="line"><span class="comment"># 2）第二步：线程1要执行对count加1的操作首先申请GIL全局解释器锁</span></span><br><span class="line"><span class="comment"># 3）第三步：调用操作系统原生线程在操作系统中执行</span></span><br><span class="line"><span class="comment"># 4）第四步：count加1还未执行完毕，时间到了被要求释放GIL</span></span><br><span class="line"><span class="comment"># 5）第五步：线程1释放了GIL后线程2此时也要对count进行操作，此时线程1还未执行完，所以count还是0</span></span><br><span class="line"><span class="comment"># 6）第六步：线程2此时拿到count = 0后也要对count进行加1操作，假如线程2执行很快，一次就完成了</span></span><br><span class="line"><span class="comment">#    count加1的操作，那么count此时就从0变成了1</span></span><br><span class="line"><span class="comment"># 7）第七步：线程2执行完加1后就赋值count=1并释放GIL</span></span><br><span class="line"><span class="comment"># 8）第八步：线程2执行完后cpu又交给了线程1，线程1根据上下文继续执行count加1操作，先拿到GIL</span></span><br><span class="line"><span class="comment">#    锁，完成加1操作，由于线程1先拿到的数据count=0，执行完加1后结果还是1</span></span><br><span class="line"><span class="comment"># 9）第九步：线程1将count=1在次赋值给count并释放GIL锁，此时连个线程都对数据加1，但是值最终是1</span></span><br></pre></td></tr></table></figure><ul><li><code>死锁定义</code><ul><li>两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</li></ul></li></ul><h3 id="1-3-多线程或者线程池"><a href="#1-3-多线程或者线程池" class="headerlink" title="1.3 多线程或者线程池"></a>1.3 多线程或者线程池</h3><ul><li>线程有哪些模块？</li><li>线程池有哪些模块？</li></ul><h3 id="1-4-join-和setDaemon"><a href="#1-4-join-和setDaemon" class="headerlink" title="1.4 join()和setDaemon()"></a>1.4 join()和setDaemon()</h3><h4 id="2-4-1-join"><a href="#2-4-1-join" class="headerlink" title="2.4.1 join()"></a>2.4.1 join()</h4><ul><li><code>实现所有线程都执行结束后再执行主线程</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.<span class="title function_">time</span>()</span><br><span class="line"></span><br><span class="line">def <span class="title function_">sayhi</span>(num): #定义每个线程要运行的函数</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&quot;running on number:%s&quot;</span> %num)</span><br><span class="line">    time.<span class="title function_">sleep</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="number">50</span>):</span><br><span class="line">    t = threading.<span class="title class_">Thread</span>(target=sayhi,args=(<span class="string">&#x27;t-%s&#x27;</span>%i,))</span><br><span class="line">    t.<span class="title function_">setDaemon</span>(<span class="title class_">True</span>)  #把当前线程变成守护线程，必须在t.<span class="title function_">start</span>()前设置</span><br><span class="line">    t.<span class="title function_">start</span>()          #启动一个线程，程序不会阻塞</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&#x27;cost time:&#x27;</span>,time.<span class="title function_">time</span>() - start_time)</span><br></pre></td></tr></table></figure><h4 id="2-4-2-setDaemon"><a href="#2-4-2-setDaemon" class="headerlink" title="2.4.2 setDaemon()"></a>2.4.2 setDaemon()</h4><ul><li><code>守护线程，主线程退出时，需要子线程随主线程退出</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.<span class="title function_">time</span>()</span><br><span class="line"></span><br><span class="line">def <span class="title function_">sayhi</span>(num): #定义每个线程要运行的函数</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&quot;running on number:%s&quot;</span> %num)</span><br><span class="line">    time.<span class="title function_">sleep</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="number">50</span>):</span><br><span class="line">    t = threading.<span class="title class_">Thread</span>(target=sayhi,args=(<span class="string">&#x27;t-%s&#x27;</span>%i,))</span><br><span class="line">    t.<span class="title function_">setDaemon</span>(<span class="title class_">True</span>)  #把当前线程变成守护线程，必须在t.<span class="title function_">start</span>()前设置</span><br><span class="line">    t.<span class="title function_">start</span>()          #启动一个线程，程序不会阻塞</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&#x27;cost time:&#x27;</span>,time.<span class="title function_">time</span>() - start_time)</span><br></pre></td></tr></table></figure><h3 id="1-5-Python中使用过的线程模块？"><a href="#1-5-Python中使用过的线程模块？" class="headerlink" title="1.5 Python中使用过的线程模块？"></a>1.5 Python中使用过的线程模块？</h3><h4 id="1-5-1-threading"><a href="#1-5-1-threading" class="headerlink" title="1.5.1 threading"></a>1.5.1 threading</h4><ul><li>Python提供了几个用于多线程编程的模块，包括thread、threading和Queue等。</li><li>thread和threading模块允许程序员创建和管理线程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayhi</span>(<span class="params">num</span>): <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running on number:%s&quot;</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">&#x27;t-%s&#x27;</span>%i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h4 id="1-5-2-concurrent-futures"><a href="#1-5-2-concurrent-futures" class="headerlink" title="1.5.2 concurrent.futures"></a>1.5.2 concurrent.futures</h4><ul><li><p><code>1、简介</code> <a href="https://docs.python.org/3/library/concurrent.futures.html">参考官网</a></p><ul><li>1、Python标准库为我们提供了threading和multiprocessing模块编写相应的多线程&#x2F;多进程代码</li><li>2、但是当项目达到一定的规模，频繁创建&#x2F;销毁进程或者线程是非常消耗资源的，这个时候我们就要编写自己的线程池&#x2F;进程池，以空间换时间。</li><li>3、但从Python3.2开始，标准库为我们提供了concurrent.futures模块，它提供了ThreadPoolExecutor和ProcessPoolExecutor两个类，</li><li>4、实现了对threading和multiprocessing的进一步抽象，对编写线程池&#x2F;进程池提供了直接的支持。</li></ul></li><li><p><code>2、Executor和Future</code></p><ul><li><p><code>1. Executor</code></p><ul><li><p>concurrent.futures模块的基础是Exectuor，Executor是一个抽象类，它不能被直接使用。</p></li><li><p>但是它提供的两个子类ThreadPoolExecutor和ProcessPoolExecutor却是非常有用</p></li><li><p>我们可以将相应的tasks直接放入线程池&#x2F;进程池，不需要维护Queue来操心死锁的问题，线程池&#x2F;进程池会自动帮我们调度。</p></li></ul></li><li><p><code>2. Future</code></p><ul><li>Future你可以把它理解为一个在未来完成的操作，这是异步编程的基础，</li><li>传统编程模式下比如我们操作queue.get的时候，在等待返回结果之前会产生阻塞，cpu不能让出来做其他事情</li><li>而Future的引入帮助我们在等待的这段时间可以完成其他的操作。</li></ul></li></ul></li><li><p>concurrent.futures.ThreadPoolExecutor 抓取网页</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_request</span>(<span class="params">url</span>):</span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(result.text)</span><br><span class="line"></span><br><span class="line">url_list = [</span><br><span class="line">    <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://www.google.com/&#x27;</span>,         <span class="comment">#google页面会卡住，知道页面超时后这个进程才结束</span></span><br><span class="line">    <span class="string">&#x27;http://dig.chouti.com/&#x27;</span>,          <span class="comment">#chouti页面内容会直接返回，不会等待Google页面的返回</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)            <span class="comment"># 创建一个线程池，最多开10个线程</span></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    pool.submit(fetch_request,url)       <span class="comment"># 去线程池中获取一个线程，线程去执行fetch_request方法</span></span><br><span class="line"></span><br><span class="line">pool.shutdown(<span class="literal">True</span>)                      <span class="comment"># 主线程自己关闭，让子线程自己拿任务执行</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.面向对象</title>
      <link href="//pages/34f94e/"/>
      <url>//pages/34f94e/</url>
      
        <content type="html"><![CDATA[<h2 id="01-面向对象"><a href="#01-面向对象" class="headerlink" title="01.面向对象"></a>01.面向对象</h2><p><a href="https://www.cnblogs.com/xiaonq/p/7880547.html#i7">https://www.cnblogs.com/xiaonq/p/7880547.html#i7</a></p><h3 id="1-1-什么是面向对象？（What）"><a href="#1-1-什么是面向对象？（What）" class="headerlink" title="1.1 什么是面向对象？（What）"></a>1.1 什么是面向对象？（What）</h3><ul><li>使用模板的思想，将世界完事万物使用对象来表示一个类型</li></ul><h3 id="1-2-封装、继承、多态？特性"><a href="#1-2-封装、继承、多态？特性" class="headerlink" title="1.2 封装、继承、多态？特性"></a>1.2 封装、继承、多态？特性</h3><ul><li>封装<ul><li>对类中属性和方法进行一种封装，隐藏了实现细节</li></ul></li><li>继承<ul><li>子类继承父类后，就具有了父类的所有属性和方法，先继承，后重写</li><li>新式类深度优先、经典类广度优先</li></ul></li><li>多态<ul><li>一种接口，多种表现形式</li><li>中国人、和美国人都能讲话，调用中国人的类讲中文，调用美国人将英文</li></ul></li></ul><h3 id="1-3-新式类-amp-经典类"><a href="#1-3-新式类-amp-经典类" class="headerlink" title="1.3 新式类&amp;经典类"></a>1.3 新式类&amp;经典类</h3><ul><li>pythn3无论新式类还是经典类都是用 广度优先</li><li>python2中，新式类：广度优先，经典类：深度优先</li></ul><p><img src="./assets/image-20200310084245988.png" style="width: 600px; margin-left: 50px;"> </img></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">talk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def talk(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;B&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">talk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(B,C):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def talk(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;A&#x27;)</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.talk()</span><br></pre></td></tr></table></figure><h3 id="1-4-静态方法、类方法、属性方法"><a href="#1-4-静态方法、类方法、属性方法" class="headerlink" title="1.4 静态方法、类方法、属性方法"></a>1.4 静态方法、类方法、属性方法</h3><ul><li>静态方法<ul><li>特点：名义上归类管理，实际上不能访问类或者变量中的任意属性或者方法</li><li>作用：让我们代码清晰，更好管理</li><li><strong>调用方式:</strong> 既可以被类直接调用，也可以通过实例调用</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am a static method&quot;</span>)</span><br><span class="line">        </span><br><span class="line">d = Dog(<span class="string">&quot;ChenRonghua&quot;</span>)</span><br><span class="line">d.eat()                       <span class="comment"># 方法1：使用实例调用</span></span><br><span class="line">Dog.eat()                     <span class="comment"># 方法2：使用类直接调用</span></span><br></pre></td></tr></table></figure><ul><li>类方法<ul><li>作用**：无需实例化直接被类调用  </li><li>特性:** 类方法只能访问类变量，不能访问实例变量</li><li>类方法使用场景：** 当我们还未创建实例，但是需要调用类中的方法</li><li>调用方式:** 既可以被类直接调用，也可以通过实例调用</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(object):</span><br><span class="line">    name = <span class="string">&#x27;类变量&#x27;</span>                  #在这里如果不定义类变量仅定义实例变量依然报错</span><br><span class="line">    def <span class="title function_">__init__</span>(self,name):</span><br><span class="line">        self.<span class="property">name</span> = <span class="string">&#x27;实例变量&#x27;</span></span><br><span class="line">        self.<span class="property">name</span> = name</span><br><span class="line">    @classmethod</span><br><span class="line">    def <span class="title function_">eat</span>(self,food):</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&quot;%s is eating %s&quot;</span>%(self.<span class="property">name</span>,food))</span><br><span class="line"><span class="title class_">Dog</span>.<span class="title function_">eat</span>(<span class="string">&#x27;baozi&#x27;</span>)                   #方法<span class="number">1</span>：使用类直接调用</span><br><span class="line">d = <span class="title class_">Dog</span>(<span class="string">&quot;ChenRonghua&quot;</span>)          </span><br><span class="line">d.<span class="title function_">eat</span>(<span class="string">&quot;包子&quot;</span>)                     #方法<span class="number">2</span>：使用实例d调用</span><br></pre></td></tr></table></figure><ul><li>属性方法<ul><li>属性方法把一个方法变成一个属性，隐藏了实现细节,调用时不必加括号直接d.eat即可调用self.eat()方法</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(object):</span><br><span class="line">    def <span class="title function_">__init__</span>(self, name):</span><br><span class="line">        self.<span class="property">name</span> = name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def <span class="title function_">eat</span>(self):</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&quot; %s is eating&quot;</span> % self.<span class="property">name</span>)</span><br><span class="line">d = <span class="title class_">Dog</span>(<span class="string">&quot;ChenRonghua&quot;</span>)</span><br><span class="line">d.<span class="title function_">eat</span>()</span><br><span class="line"># 调用会出以下错误， 说<span class="title class_">NoneType</span> is not callable, 因为eat此时已经变成一个静态属性了， </span><br><span class="line"># 不是方法了， 想调用已经不需要加()号了，直接d.<span class="property">eat</span>就可以了</span><br></pre></td></tr></table></figure><h3 id="1-5-魔法方法"><a href="#1-5-魔法方法" class="headerlink" title="1.5 魔法方法"></a>1.5 魔法方法</h3><ul><li>_<em>new</em>_<ul><li>产生一个实例</li></ul></li><li>_<em>init</em>_<ul><li>产生一个对象</li></ul></li><li>_<em>del</em>_<ul><li>析构方法，删除无用的内存对象（当程序结束会自动自行析构方法）</li></ul></li><li><img src="./assets/image-20200310095320872.png" style="width: 600px; margin-left: 20px;"> </img></li></ul><h3 id="1-6-反射"><a href="#1-6-反射" class="headerlink" title="1.6 反射"></a>1.6 反射</h3><ul><li>hasattr: 判断当前类是否有这个方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self,food</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;eat method!!!&quot;</span>)</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line"><span class="comment">#hasattr判断对象d是否有eat方法，有返回True，没有返回False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(d,<span class="string">&#x27;eat&#x27;</span>))     <span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(d,<span class="string">&#x27;cat&#x27;</span>))     <span class="comment">#False</span></span><br></pre></td></tr></table></figure><ul><li>getattr: 通过字符串反射出这个方法的内存地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;eat method!!!&quot;</span>)</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(d,<span class="string">&#x27;eat&#x27;</span>):          <span class="comment"># hasattr判断实例是否有eat方法</span></span><br><span class="line">    func = <span class="built_in">getattr</span>(d, <span class="string">&#x27;eat&#x27;</span>)  <span class="comment"># getattr获取实例d的eat方法内存地址</span></span><br><span class="line">    func()                    <span class="comment"># 执行实例d的eat方法</span></span><br><span class="line"><span class="comment">#运行结果：  eat method!!!</span></span><br></pre></td></tr></table></figure><ul><li>setattr：将当前类添加一个方法</li><li>delatrr: 删除实例属性</li></ul><h3 id="1-7-单例模式"><a href="#1-7-单例模式" class="headerlink" title="1.7 单例模式"></a>1.7 单例模式</h3><ul><li>单例模式：永远用一个对象得实例，避免新建太多实例浪费资源</li><li>实质：使用__new__方法新建类对象时先判断是否已经建立过，如果建过就使用已有的对象</li><li>使用场景：如果每个对象内部封装的值都相同就可以用单例模式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   instance = <span class="literal">None</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">      self.name = <span class="string">&#x27;alex&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">      <span class="keyword">if</span> Foo.instance:</span><br><span class="line">         <span class="keyword">return</span> Foo.instance</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         Foo.instance = <span class="built_in">object</span>.__new__(cls,*args,**kwargs)</span><br><span class="line">         <span class="keyword">return</span> Foo.instance</span><br><span class="line"></span><br><span class="line">obj1 = Foo()       <span class="comment"># obj1和obj2获取的就是__new__方法返回的内容</span></span><br><span class="line">obj2 = Foo()</span><br><span class="line"><span class="built_in">print</span>(obj1,obj2)   <span class="comment"># 运行结果： &lt;__main__.Foo object at 0x00D3B450&gt;    &lt;__main__.Foo object at 0x00D3B450&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果说明：</span></span><br><span class="line"><span class="comment"># 这可以看到我们新建的两个Foo()对象内存地址相同，说明使用的•同一个类，没有重复建立类</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.装饰器</title>
      <link href="//pages/0e4385/"/>
      <url>//pages/0e4385/</url>
      
        <content type="html"><![CDATA[<h2 id="01-装饰器"><a href="#01-装饰器" class="headerlink" title="01.装饰器"></a>01.装饰器</h2><h3 id="1-1-什么是装饰器-（What）"><a href="#1-1-什么是装饰器-（What）" class="headerlink" title="1.1 什么是装饰器?（What）"></a>1.1 什么是装饰器?（What）</h3><ul><li><code>装饰器本质是函数，用来给其他函数添加新的功能</code></li><li>特点：<code>不修改调用方式、不修改源代码</code></li></ul><h3 id="1-2-装饰器的应用场景？（Where）"><a href="#1-2-装饰器的应用场景？（Where）" class="headerlink" title="1.2 装饰器的应用场景？（Where）"></a>1.2 装饰器的应用场景？（Where）</h3><ul><li>用户认证，判断用户是否登录</li><li>计算函数运行时间（算是一个功能、在项目里用的不多）</li><li>插入日志的时候</li><li>redis缓存</li></ul><h3 id="1-3-为什么使用装饰器？（Why）"><a href="#1-3-为什么使用装饰器？（Why）" class="headerlink" title="1.3 为什么使用装饰器？（Why）"></a>1.3 为什么使用装饰器？（Why）</h3><ul><li>结合应用场景说需求</li></ul><h3 id="1-4-如何使用装饰器？（How）"><a href="#1-4-如何使用装饰器？（How）" class="headerlink" title="1.4 如何使用装饰器？（How）"></a>1.4 如何使用装饰器？（How）</h3><h4 id="1-4-1-装饰器求函数运行时间"><a href="#1-4-1-装饰器求函数运行时间" class="headerlink" title="1.4.1 装饰器求函数运行时间"></a>1.4.1 装饰器求函数运行时间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):   <span class="comment">#timer(test1)  func=test1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func(*args,**kwargs)      <span class="comment">#run test1</span></span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;running time is %s&quot;</span>%(stop_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer     </span><span class="comment"># test1=timer(test1)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the test1&quot;</span>)</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><h4 id="1-4-2-三级装饰器"><a href="#1-4-2-三级装饰器" class="headerlink" title="1.4.2 三级装饰器"></a>1.4.2 三级装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">auth</span>(<span class="params">auth_type</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;auth func:&quot;</span>,auth_type)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">outer_wrapper</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;wrapper func args:&quot;</span>, *args, **kwargs)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;运行前&#x27;</span>)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;运行后&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> outer_wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(<span class="params">auth_type=<span class="string">&quot;local&quot;</span></span>) </span><span class="comment"># home = wrapper()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;welcome to home  page&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;from home&quot;</span></span><br><span class="line">home()</span><br></pre></td></tr></table></figure><h3 id="1-5-装饰器在项目中应用场景"><a href="#1-5-装饰器在项目中应用场景" class="headerlink" title="1.5 装饰器在项目中应用场景"></a>1.5 装饰器在项目中应用场景</h3><ul><li><code>身份验证</code></li><li>写入日志</li><li>redis缓存</li></ul><h4 id="1-5-1-身份验证"><a href="#1-5-1-身份验证" class="headerlink" title="1.5.1 身份验证"></a>1.5.1 身份验证</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">user,passwd = <span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">auth</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">username,password,*args,**kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> user == username <span class="keyword">and</span> password == passwd:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;User has passed authentication&quot;</span>)</span><br><span class="line">            res = func(username,password,*args,**kwargs)   <span class="comment">#这里执行func()相当于执行调用的函数如home()</span></span><br><span class="line">            <span class="keyword">return</span> res          <span class="comment">#为了获得home()函数返回值，可以将执行结果赋值给res然后返回print(home())结果是&quot;from home&quot;而不是&quot;None&quot;了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;非合法用户&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>(<span class="params">username,password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;welcome to home page&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;from home&quot;</span></span><br><span class="line"></span><br><span class="line">home(<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="1-5-2-记录日志"><a href="#1-5-2-记录日志" class="headerlink" title="1.5.2 记录日志"></a>1.5.2 记录日志</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decoratore</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前运行方法&quot;</span>,func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(traceback.format_exc())  <span class="comment"># 这里应该调用log模块来记录到日志里</span></span><br><span class="line">    <span class="keyword">return</span> log</span><br><span class="line"></span><br><span class="line"><span class="meta">@decoratore</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">int</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 上面运行结果</span></span><br><span class="line"><span class="string">    当前运行方法 test</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      File &quot;C:/Users/tom/Desktop/alipay_demo/aaa/t2.py&quot;, line 11, in log</span></span><br><span class="line"><span class="string">        return func(*args,**kwargs)</span></span><br><span class="line"><span class="string">      File &quot;C:/Users/tom/Desktop/alipay_demo/aaa/t2.py&quot;, line 18, in test</span></span><br><span class="line"><span class="string">        int(&#x27;a&#x27;)</span></span><br><span class="line"><span class="string">    ValueError: invalid literal for int() with base 10: &#x27;a&#x27;</span></span><br><span class="line"><span class="string">     22222</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-3-redis缓存"><a href="#1-5-3-redis缓存" class="headerlink" title="1.5.3 redis缓存"></a>1.5.3 redis缓存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：查询redis缓存是否存在这个key</span><br><span class="line">第二步：如果存在这个key，不用去mysql中查询，直接从redis中取出数据即可（减轻了mysql压力）</span><br><span class="line">第三步：如果查询的key不存在，先到mysql中查询数据，让后设置到redis中，下次查询就有了</span><br></pre></td></tr></table></figure><h5 id="1-5-3-1-2B青年实现"><a href="#1-5-3-1-2B青年实现" class="headerlink" title="1.5.3.1 2B青年实现"></a>1.5.3.1 2B青年实现</h5><ul><li>2B青年每一个需要使用缓存的数据，我都写一个方法获取数据，再写一个方法处理缓存。</li><li>若需要用到缓存的地方越来越多，每一个都需要这么写一套代码，代码冗余繁琐。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取readed缓存</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_readed_cache</span>():</span><br><span class="line">    <span class="comment"># 判断键是否存在</span></span><br><span class="line">    key = <span class="string">&#x27;readed&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> cache.has_key(key):</span><br><span class="line">        data = cache.get(key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 不存在，则通过sql语句获取数据，并写入缓存,这里只是一个举例的sql语句</span></span><br><span class="line">        data = <span class="string">&quot;select name from tb&quot;</span></span><br><span class="line">        <span class="comment"># 写入缓存</span></span><br><span class="line">        cache.<span class="built_in">set</span>(key, data, <span class="number">3600</span> - <span class="built_in">int</span>(time.time() % <span class="number">3600</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    data = get_readed_cache()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    data = get_readed_cache()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test1()</span><br><span class="line">    test2()</span><br></pre></td></tr></table></figure><h5 id="1-5-3-2-NB青年"><a href="#1-5-3-2-NB青年" class="headerlink" title="1.5.3.2 NB青年"></a>1.5.3.2 NB青年</h5><ul><li>NB青年可以使用三级装饰器，在装饰器中判断key如果存在就从reids中获取，如果不存在就从数据库查询，并设置到reids中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取redis缓存的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redis_cache</span>(<span class="params">key, timeout</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__redis_cache</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warpper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="keyword">if</span> cache.has_key(key):  <span class="comment"># 判断缓存是否存在</span></span><br><span class="line">                data = cache.get(key)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若不存在则执行获取数据的方法</span></span><br><span class="line">                <span class="comment"># 注意返回数据的类型(字符串，数字，字典，列表均可)</span></span><br><span class="line">                data = func(*args, **kw)   <span class="comment"># 从数据库查询到数据设置到redis中</span></span><br><span class="line">                cache.<span class="built_in">set</span>(key, data, timeout)</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">return</span> warpper</span><br><span class="line">    <span class="keyword">return</span> __redis_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">#键值为test，超时时间为60秒</span></span><br><span class="line"><span class="meta">@redis_cache(<span class="params"><span class="string">&#x27;test&#x27;</span>, <span class="number">60</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_test_data</span>():</span><br><span class="line">    <span class="comment"># 获取Blog模型随机排序前3条数据</span></span><br><span class="line">    <span class="comment"># (Blog模型是我自己的模型，具体代码根据自己需求获取数据)</span></span><br><span class="line">    <span class="comment"># values执行结果，将返回一个字典。字典可以直接存入redis</span></span><br><span class="line">    <span class="comment"># data = Blog.objects.values(&#x27;id&#x27;, &#x27;caption&#x27;).order_by(&#x27;?&#x27;)[:3]</span></span><br><span class="line">    data = <span class="string">&#x27;从数据库查询到了数据&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_test_data()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.上下文管理</title>
      <link href="//pages/ff07de/"/>
      <url>//pages/ff07de/</url>
      
        <content type="html"><![CDATA[<h2 id="01-上下文管理"><a href="#01-上下文管理" class="headerlink" title="01.上下文管理"></a>01.上下文管理</h2><ul><li><p>1、什么是with语句</p><ul><li>with是一种上下文管理协议，目的在于从流程图中把 try,except 和finally 关键字和资源分配释放相关代码统统去掉，简化try….except….finlally的处理流程。</li><li>所以使用with处理的对象必须有enter()和exit()这两个方法<ul><li>1）with通过enter方法初始化（enter方法在语句体执行之前进入运行）</li><li>然后在exit中做善后以及处理异常（exit()方法在语句体执行完毕退出后运行）</li></ul></li></ul></li><li><p>2、with语句使用场景</p><ul><li>with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源</li><li>比如文件使用后自动关闭、线程中锁的自动获取和释放等。</li></ul></li><li><p>3、with处理文件操作的实例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这段代码的作用：打开一个文件，如果一切正常，把文件对象赋值给f，然后用迭代器遍历文件中每一行，当完成时，关闭文件；</span></span><br><span class="line"><span class="comment"># 而无论在这段代码的任何地方，如果发生异常，此时文件仍会被关闭。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a2.py&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>( f.readlines())</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;a2.py&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    f.read()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">print</span>(e))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.生成器和迭代器</title>
      <link href="//pages/0a2618/"/>
      <url>//pages/0a2618/</url>
      
        <content type="html"><![CDATA[<h2 id="01-生成器"><a href="#01-生成器" class="headerlink" title="01.生成器"></a>01.生成器</h2><h3 id="1-1-什么是生成器-What"><a href="#1-1-什么是生成器-What" class="headerlink" title="1.1 什么是生成器?(What)"></a>1.1 什么是生成器?(What)</h3><ul><li>生成器就是一个特殊的迭代器</li><li>一个有yield关键字的函数就是一个生成器<ul><li>生成器是这样一个函数，它记住上一次返回时在函数体中的位置。</li><li>对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r1 = <span class="title function_">test</span>()</span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">__next__</span>()</span><br><span class="line">r1.<span class="title function_">__next__</span>()</span><br></pre></td></tr></table></figure><h3 id="1-2-生成器哪些场景应用？（Where）"><a href="#1-2-生成器哪些场景应用？（Where）" class="headerlink" title="1.2 生成器哪些场景应用？（Where）"></a>1.2 生成器哪些场景应用？（Where）</h3><ul><li><p>生成器是一个概念，我们平常写代码可能用的并不多，但是python源码大量使用</p></li><li><p>比如我们tornado框架就是基于 生成器+协程</p></li><li><p>在我们代码中使用举例</p></li><li><p>比如我们要生成一百万个数据，如果用生成器非常节省空间，用列表浪费大量空间</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">t1 = time.time()</span><br><span class="line">g = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>))</span><br><span class="line">t2 = time.time()</span><br><span class="line">lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>)]</span><br><span class="line">t3 = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;生成器时间：&#x27;</span>,t2 - t1)  <span class="comment"># 生成器时间： 0.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;列表时间：&#x27;</span>,t3 - t2)    <span class="comment"># 列表时间： 5.821957349777222</span></span><br></pre></td></tr></table></figure><h3 id="1-3-为什么使用生成器"><a href="#1-3-为什么使用生成器" class="headerlink" title="1.3 为什么使用生成器"></a>1.3 为什么使用生成器</h3><ul><li>节省空间</li><li>高效</li></ul><h2 id="02-迭代器"><a href="#02-迭代器" class="headerlink" title="02.迭代器"></a>02.迭代器</h2><h3 id="2-1-什么是迭代器-W"><a href="#2-1-什么是迭代器-W" class="headerlink" title="2.1 什么是迭代器(W)"></a>2.1 什么是迭代器(W)</h3><ul><li>迭代器是访问集合内元素的一种方法<ul><li>总是从集合内第一个元素访问，直到所有元素都被访问过结束，当调用 __next__而元素返回会引发一个，StopIteration异常</li></ul></li><li>有两个方法：_<em>iter</em>_ _<em>next</em>_<ul><li>_<em>iter</em>_ : 返回迭代器自身</li><li>_<em>next</em>_: 返回下一个元素</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.select、poll、epoll</title>
      <link href="//pages/d776ab/"/>
      <url>//pages/d776ab/</url>
      
        <content type="html"><![CDATA[<h2 id="01-select、epoll、poll"><a href="#01-select、epoll、poll" class="headerlink" title="01.select、epoll、poll"></a>01.select、epoll、poll</h2><ul><li>select、poll、epoll是内核的服务<ul><li>windows下只有 select服务、poll</li><li>Linux下：select、poll、epoll</li></ul></li><li>怎么使用<ul><li>协程</li><li>tornado</li></ul></li></ul><p><a href="https://www.cnblogs.com/xiaonq/p/7907871.html">https://www.cnblogs.com/xiaonq/p/7907871.html</a></p><h3 id="1-1-I-x2F-O-多路复用"><a href="#1-1-I-x2F-O-多路复用" class="headerlink" title="1.1 I&#x2F;O 多路复用"></a>1.1 I&#x2F;O 多路复用</h3><ul><li><p>特点： 用户还是要等待数据从kernel拷贝到用户进程</p></li><li><p>IO multiplexing就是我们说的<code>select，poll，epoll</code>，有些地方也称这种IO方式为event driven IO</p></li><li><p>它的基本原理就是select，poll，epoll这个function会<code>不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程</code></p><ul><li>1）当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket</li><li>2）当任何一个socket中的数据准备好了，select就会返回</li><li>3）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</li><li>4）虽然是多并发但是还有一些卡，因为都要等待数据从kernel拷贝到用户进程</li><li>5）其实select，poll，epoll实质就是循环着接收数据　　</li><li>6）select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</li></ul></li></ul><h3 id="1-2-I-x2F-O的实质是什么？"><a href="#1-2-I-x2F-O的实质是什么？" class="headerlink" title="1.2 I&#x2F;O的实质是什么？"></a>1.2 I&#x2F;O的实质是什么？</h3><ul><li><p>I&#x2F;O的实质是什么？</p><ul><li>I&#x2F;O的实质是将硬盘中的数据，或收到的数据实现从内核态 copy到 用户态的过程</li><li>比如微信读取本地硬盘的过程<ul><li>微信进程会发送一个读取硬盘的请求—-》操作系统</li><li>只有内核才能够读取硬盘中的数据—》数据返回给微信程序（看上去就好像是微信直接读取）</li></ul></li></ul></li><li><p>用户态 &amp; 内核态</p><ul><li>系统空间分为两个部分，一部分是内核态，一部分是用户态的部分</li><li>内核态：内核态的空间资源只有操作系统能够访问</li><li>用户态：我们写的普通程序使用的空间</li></ul></li></ul><p><img src="/./assets/image-20210211160535533.png" alt="image-20210211160535533"></p><h3 id="1-3-select、poll、epoll特点"><a href="#1-3-select、poll、epoll特点" class="headerlink" title="1.3 select、poll、epoll特点"></a>1.3 select、poll、epoll特点</h3><ul><li><p>select</p><ul><li>只能处理1024个连接（每一个请求都可以理解为一个连接）</li><li>不能告诉用户程序，哪一个连接是活跃的</li></ul></li><li><p>pool</p><ul><li>只是取消了最大1024个活跃的限制</li><li>不能告诉用户程序，哪一个连接是活跃的</li></ul></li><li><p>epool</p><ul><li>不仅取消了1024这个最大连接限制</li><li>而且能告诉用户程序哪一个是活跃的</li></ul></li></ul><h3 id="1-4-epoll本质"><a href="#1-4-epoll本质" class="headerlink" title="1.4 epoll本质"></a>1.4 epoll本质</h3><ul><li><p>简单说法</p><ul><li>协程遇到I&#x2F;O后自动切换，但是会保持一个socket连接，交给系统内核去处理工作</li><li>epoll()就工作内核中，他维护了一个链表，来存放所有的socket连接</li><li>当内核处理完成后就会回调一个函数，以socket文件描述符为key，结果为value存放到字典中</li><li>此时这个列表还是在内核中，需要将这个字典拷贝到用户空间（用户进程中）</li></ul></li><li><p>本质</p><ul><li>1.<code>epoll()中内核则维护一个链表</code>，epoll_wait直接检查链表是不是空就知道是否有文件描述符准备好了。</li><li>2.在内核实现中epoll是根据每个sockfd上面的与设备驱动程序建立起来的回调函数实现的。</li><li>3.某个sockfd上的事件发生时，与它对应的回调函数就会被调用，来把这个sockfd加入链表，其他处于“空闲的”状态的则不会。</li><li>4.epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术，避免了复制大量文件描述符带来的开销</li><li>内存映射（mmap）：内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行I&#x2F;O操作</li></ul></li></ul><img src="./assets/image-20210211160608539.png" alt="image-20210211160608539"  />]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.垃圾回收</title>
      <link href="//pages/520a3e/"/>
      <url>//pages/520a3e/</url>
      
        <content type="html"><![CDATA[<h2 id="01-python垃圾回收机制"><a href="#01-python垃圾回收机制" class="headerlink" title="01.python垃圾回收机制"></a>01.python垃圾回收机制</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(object):</span><br><span class="line">    def <span class="title function_">__del__</span>(self):                # 作用：清除无用的实例对内存的暂用</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&#x27;__del__&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s1 = <span class="title class_">Student</span>()</span><br><span class="line">s2 = s1</span><br><span class="line">del s2</span><br><span class="line">del s1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.<span class="title function_">sleep</span>(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="1-1-引计数"><a href="#1-1-引计数" class="headerlink" title="1.1 引计数"></a>1.1 引计数</h3><ul><li>原理<ul><li>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1.</li><li>当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</li></ul></li><li>优点<ul><li>引用计数有一个很大的优点，即实时性，任何内存，一旦没有指向它的引用，就会被立即回收，而其他的垃圾收集技术必须在某种特殊条件下才能进行无效内存的回收。</li></ul></li><li>缺点<ul><li>引用计数机制所带来的维护引用计数的额外操作与Python运行中所进行的内存分配和释放，引用赋值的次数是成正比的，</li><li>显然比其它那些垃圾收集技术所带来的额外操作只是与待回收的内存数量有关的效率要低。</li><li>同时，因为对象之间相互引用，每个对象的引用都不会为0，所以这些对象所占用的内存始终都不会被释放掉。</li></ul></li></ul><h3 id="1-2-标记－清除"><a href="#1-2-标记－清除" class="headerlink" title="1.2 标记－清除"></a>1.2 标记－清除</h3><ul><li>它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。</li><li>对象之间通过引用（指针）连在一起，构成一个有向图</li><li>从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。</li><li>根对象就是全局变量、调用栈、寄存器。</li></ul><p><img src="/./assets/image-20200311091914402.png"></p><ul><li>在上图中，可以从程序变量直接访问块1，并且可以间接访问块2和3,程序无法访问块4和5</li><li>第一步将标记块1，并记住块2和3以供稍后处理。</li><li>第二步将标记块2，第三步将标记块3，但不记得块2，因为它已被标记。</li><li>扫描阶段将忽略块1，2和3，因为它们已被标记，但会回收块4和5。</li></ul><h3 id="1-3-分代回收"><a href="#1-3-分代回收" class="headerlink" title="1.3 分代回收"></a>1.3 分代回收</h3><ul><li>分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。</li><li>Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代）</li><li>他们对应的是3个链表，它们的<strong>垃圾收集频率与对象的存活时间的增大而减小</strong>。</li><li>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发</li><li>把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推</li><li>老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.网络七层</title>
      <link href="//pages/2d9cd4/"/>
      <url>//pages/2d9cd4/</url>
      
        <content type="html"><![CDATA[<h2 id="01-网络七层与TCP"><a href="#01-网络七层与TCP" class="headerlink" title="01.网络七层与TCP"></a>01.网络七层与TCP</h2><p><a href="https://www.cnblogs.com/xiaonq/p/10470551.html">https://www.cnblogs.com/xiaonq/p/10470551.html</a></p><h3 id="1-1-网络七层"><a href="#1-1-网络七层" class="headerlink" title="1.1 网络七层"></a>1.1 网络七层</h3><img src="./assets/image-20210118163519958.png" style="zoom:80%;" /><h3 id="1-2-TCP三层握手"><a href="#1-2-TCP三层握手" class="headerlink" title="1.2 TCP三层握手"></a>1.2 TCP三层握手</h3><img src="./assets/image-20210118163645279.png" style="zoom:80%;" /><h3 id="1-3-TCP与UDP比较"><a href="#1-3-TCP与UDP比较" class="headerlink" title="1.3 TCP与UDP比较"></a>1.3 TCP与UDP比较</h3><ul><li><p>1.TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p></li><li><p>2.TCP提供可靠的服务，也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p></li><li><p>3.Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。</p></li><li><p>4.UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p></li><li><p>5.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p></li><li><p>6.TCP对系统资源要求较多，UDP对系统资源要求较少。</p></li><li><p>注：UDP一般用于即时通信（QQ聊天对数据准确性和丢包要求比较低，但速度必须快），在线视频等</p></li><li><p>tcp&#x2F;udp相关协议</p><ul><li>1.TCP:STMP,TELNET,HTTP,FTP</li><li>2.UDP:DNS,TFTP,RIP,DHCP,SNMP</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16.高阶函数</title>
      <link href="//pages/a18e2b/"/>
      <url>//pages/a18e2b/</url>
      
        <content type="html"><![CDATA[<h2 id="00-匿名函数"><a href="#00-匿名函数" class="headerlink" title="00.匿名函数"></a>00.匿名函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x,y,z:x+y+z</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">x,y,z</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x:x <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">10</span>))                    <span class="comment"># 110</span></span><br></pre></td></tr></table></figure><ul><li>三元运算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Tom&#x27;</span> <span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="string">&#x27;fly&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="comment"># 运行结果： Tom</span></span><br></pre></td></tr></table></figure><h2 id="01-filter"><a href="#01-filter" class="headerlink" title="01.filter"></a>01.<code>filter</code></h2><ul><li>filter()函数可以对序列做过滤处理，就是说可以使用一个自定的函数过滤一个序列，把序列的每一项传到自定义的过滤函数里处理，并返回结果做过滤。</li><li>最终一次性返回过滤后的结果。</li><li>filter()函数有两个参数：<ul><li>第一个，自定函数名，必须的</li><li>第二个，需要过滤的列，也是必须的</li></ul></li><li>利用 filter、lambda表达式 获取l1中元素小于33的所有元素 l1 &#x3D; [11, 22, 33, 44, 55]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1= [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">a = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x&lt;<span class="number">33</span>, l1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">33</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">b = <span class="built_in">filter</span>(F,l1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(b))<span class="number">111</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入 &#x27;102304&#x27;  ==&gt; [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br><span class="line">l1= <span class="string">&#x27;102304&#x27;</span></span><br><span class="line">a = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x !=<span class="string">&#x27;0&#x27;</span>, l1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))</span><br></pre></td></tr></table></figure><h2 id="02-map"><a href="#02-map" class="headerlink" title="02.map"></a>02.<code>map</code></h2><ul><li>第一个参数接收一个函数名，第二个参数接收一个可迭代对象</li><li>利用map，lambda表达式将所有偶数元素加100</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line">l1= [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">ret = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x-<span class="number">100</span> <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">100</span>,l1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ret))</span><br><span class="line"><span class="comment"># 运行结果： [-89, 122, -67, 144, -45]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lambda x:x-100 if x % 2 != 0 else x + 100</span></span><br><span class="line"><span class="comment"># 如果 &quot;if x % 2 != 0&quot; 条件成立返回 x-100</span></span><br><span class="line"><span class="comment"># 不成立：返回 x+100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x%<span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x-<span class="number">100</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x+<span class="number">100</span></span><br><span class="line">ret = <span class="built_in">map</span>(F,l1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ret))</span><br></pre></td></tr></table></figure><h2 id="03-reduce"><a href="#03-reduce" class="headerlink" title="03.reduce"></a>03.<code>reduce</code></h2><ul><li>字符串反转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;使用reduce将字符串反转&#x27;&#x27;&#x27;</span></span><br><span class="line">s = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x,y:y+x,s)</span><br><span class="line"><span class="comment"># # 1、第一次：x=H,y=e  =&gt; y+x = eH</span></span><br><span class="line"><span class="comment"># # 2、第二次：x=l,y=eH  =&gt; y+x = leH</span></span><br><span class="line"><span class="comment"># # 3、第三次：x=l,y=leH  =&gt; y+x = lleH</span></span><br><span class="line"><span class="built_in">print</span>( result )      <span class="comment"># dlroW olleH</span></span><br></pre></td></tr></table></figure><h2 id="04-sorted"><a href="#04-sorted" class="headerlink" title="04.sorted"></a>04.<code>sorted</code></h2><ul><li>经典面试题只 列表排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">students = [(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>), (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="comment"># [(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)]</span></span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> s: s[<span class="number">2</span>], reverse=<span class="literal">False</span>) )    <span class="comment"># 按年龄排序</span></span><br><span class="line"><span class="comment"># 结果：[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># (&#x27;john&#x27;, &#x27;A&#x27;, 15)</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">sorted</span>(students, key=f, reverse=<span class="literal">False</span>) )    <span class="comment"># 按年龄排序</span></span><br></pre></td></tr></table></figure><ul><li>对字典的value排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;k3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># d.items() = [(&#x27;k1&#x27;, 1), (&#x27;k3&#x27;, 3), (&#x27;k2&#x27;, 2)]</span></span><br><span class="line">a = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(a)            <span class="comment"># [(&#x27;k1&#x27;, 1), (&#x27;k2&#x27;, 2), (&#x27;k3&#x27;, 3)]</span></span><br></pre></td></tr></table></figure><ul><li>两个列表编一个字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L1 = [<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>,<span class="string">&#x27;k3&#x27;</span>]</span><br><span class="line">L2 = [<span class="string">&#x27;v1&#x27;</span>,<span class="string">&#x27;v2&#x27;</span>,<span class="string">&#x27;v3&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>(<span class="built_in">zip</span>(L1,L2)))</span><br><span class="line"><span class="comment"># zip(L1,L2) : [(&#x27;k1&#x27;, &#x27;v1&#x27;), (&#x27;k2&#x27;, &#x27;v2&#x27;), (&#x27;k3&#x27;, &#x27;v3&#x27;)]</span></span><br><span class="line"><span class="comment"># dict( [(&#x27;k1&#x27;, &#x27;v1&#x27;), (&#x27;k2&#x27;, &#x27;v2&#x27;), (&#x27;k3&#x27;, &#x27;v3&#x27;)] )  = &#123;&#x27;k1&#x27;: &#x27;v1&#x27;, &#x27;k2&#x27;: &#x27;v2&#x27;, &#x27;k3&#x27;: &#x27;v3&#x27;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.次重点</title>
      <link href="//pages/480866/"/>
      <url>//pages/480866/</url>
      
        <content type="html"><![CDATA[<h2 id="01-读写文件"><a href="#01-读写文件" class="headerlink" title="01.读写文件"></a>01.读写文件</h2><ul><li><p>读写文件（python如何读取大文件）：<a href="https://www.cnblogs.com/xiaonq/p/7860309.html">https://www.cnblogs.com/xiaonq/p/7860309.html</a></p></li><li><p>经典面试题：现在有一个5G的文件，用python写入另一个文件里</p><ul><li>read(): 指定读取指定大小的文件（默认一次读取所有）</li><li>readline(): 逐行读取，适合读大文件</li><li>readlines(): 一次性读取所有文件， 将文件按行读取成列表</li></ul></li><li><p>我们使用了一个 while 循环来读取文件内容，每次最多读取 8kb 大小</p></li><li><p>这样可以避免之前需要拼接一个巨大字符串的过程，把内存占用降低非常多。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_big_file_v</span>(<span class="params">fname</span>):</span><br><span class="line">    block_size = <span class="number">1024</span> * <span class="number">8</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname,encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = fp.read(block_size)</span><br><span class="line">            <span class="comment"># 当文件没有更多内容时，read 调用将会返回空字符串 &#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(chunk)</span><br><span class="line">path = <span class="string">r&#x27;C:\aaa\luting\edc-backend\tttt.py&#x27;</span></span><br><span class="line">read_big_file_v(path)</span><br></pre></td></tr></table></figure><h2 id="02-字符编码"><a href="#02-字符编码" class="headerlink" title="02.字符编码"></a>02.字符编码</h2><ul><li><p>各种编码由来</p><ul><li>ASCII       :  不支持中文（<strong>一个字母一个字节：a&#x2F;b&#x2F;c</strong>）</li><li>GBK        :  是中国的中文字符，其包含了简体中文和繁体中文的字符</li><li>Unicode :  万国编码（Unicode 包含GBK）</li></ul></li><li><p>Unicode（<strong>每个字母需要用两个字节：a&#x2F;b&#x2F;c</strong>）</p><ul><li>存储所有字符串都用连个字节</li><li>Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码</li><li>规定所有的字符和符号最少由 16 位来表示（2个字节），即：2 **16 &#x3D; 65536</li><li>这里还有个问题：使用的字节增加了，那么造成的直接影响就是使用的空间就直接翻倍了</li></ul></li><li><p>Utf-8       : 可变长码, 是Unicode 的扩展集</p><ul><li><p>UTF-8编码：是对Unicode编码的压缩和优化，他不再使用最少使用2个字节，而是将所有的字符和符号进行分类</p></li><li><p>ascii码中的内容用1个字节保存、欧洲的字符用2个字节保存，东亚的字符用3个字节保存…</p></li><li><p><strong>存一个a字母用一个字节，存一个中文用三个字节</strong></p></li></ul></li><li><p>python2与python3的几个区别　</p><ul><li>Python2默认 编码方式为ASCII， Python3  默认编码方式为UTF-8（是Unicode 的扩展集）</li><li>python2中字符串有str和unicode两种类型， python3 中字符串有str和字节(bytes) 两种类型</li><li>python3中不再支持u中文的语法格式</li></ul></li><li><p>python2和python3中编码转换</p><ul><li>在python3中字符串默认是unicode所以不需要decode()，直接encode成想要转换的编码如gb2312</li><li>在python2中默认是ASCII编码，必须先转换成Unicode，Unicode 可以作为各种编码的转换的中转站</li></ul></li></ul><h2 id="03-常用模块"><a href="#03-常用模块" class="headerlink" title="03.常用模块"></a>03.常用模块</h2><ul><li>（re）(paramiko、subprocess)：<a href="https://www.cnblogs.com/xiaonq/p/7866925.html">https://www.cnblogs.com/xiaonq/p/7866925.html</a></li></ul><h2 id="04-python2与python3的区别"><a href="#04-python2与python3的区别" class="headerlink" title="04.python2与python3的区别"></a>04.python2与python3的区别</h2><p><a href="https://www.cnblogs.com/xiaonq/p/8706111.html">https://www.cnblogs.com/xiaonq/p/8706111.html</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.深浅拷贝</title>
      <link href="//pages/d35123/"/>
      <url>//pages/d35123/</url>
      
        <content type="html"><![CDATA[<h2 id="01-深浅拷贝"><a href="#01-深浅拷贝" class="headerlink" title="01.深浅拷贝"></a>01.深浅拷贝</h2><ul><li><p><strong>浅copy与deepcopy</strong>（What）</p><ul><li><strong>浅copy：</strong> 不管多么复杂的数据结构，浅拷贝都只会copy一层</li><li><strong>deepcopy</strong> : 深拷贝会完全复制原变量相关的所有数据，在内存中生成一套完全一样的内容，我们对这两个变量中任意一个修改都不会影响其他变量</li></ul></li><li><p>&#96;&#96;&#96;python<br>import copy<br>sourceList &#x3D; [1,2,3,[4,5,6]]<br>copyList &#x3D; copy.copy(sourceList)<br>deepcopyList &#x3D; copy.deepcopy(sourceList)</p><p>sourceList[3][0]&#x3D;100</p><p>print(sourceList)           # [1, 2, 3, [100, 5, 6]]<br>print(copyList)             # [1, 2, 3, [100, 5, 6]]<br>print(deepcopyList)         # [1, 2, 3, [4, 5, 6]]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20200311090206377.png](./assets/image-20200311090206377.png)</span><br><span class="line"></span><br><span class="line">- 案例</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import copy</span><br><span class="line">a = [1,2,3,4,[&#x27;a&#x27;,&#x27;b&#x27;]]</span><br><span class="line">b = a</span><br><span class="line">c = copy.copy(a)</span><br><span class="line">d = copy.deepcopy(a)</span><br><span class="line">a.append(5)</span><br><span class="line">a[4].append(&#x27;c&#x27;)</span><br><span class="line">print(a)     # [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 5]</span><br><span class="line">print(b)     # [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 5]</span><br><span class="line">print(c)     # [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]]</span><br><span class="line">print(d)     # [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;]]</span><br></pre></td></tr></table></figure></li></ul><h2 id="02-变量及其存储"><a href="#02-变量及其存储" class="headerlink" title="02.变量及其存储"></a>02.变量及其存储</h2><ul><li><ol><li>python的一切变量都是对象，变量的存储，采用了引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的只本身</li></ol></li><li><ol start="2"><li>不管多么复杂的数据结构，浅拷贝都只会copy一层。</li></ol></li><li><p><strong>理解</strong>：两个人公用一张桌子，只要桌子不变，桌子上的菜发生了变化两个人是共同感受的。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = str1</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、让str1和str2变量都存储了‘hello’所在的内存地址</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(str1)</span><br><span class="line"><span class="number">22748280</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(str1)</span><br><span class="line"><span class="number">22748280</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、当str1的值变成‘new hello’后str1的值被重新赋值成&#x27;new hello&#x27;的内存地址，而str2的值依旧是‘hello’的内存地址</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&#x27;new hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(str1)</span><br><span class="line"><span class="number">22748320</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(str2)</span><br><span class="line"><span class="number">22748280</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、不管多么复杂的数据结构，浅拷贝都只会copy一层。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sourceList = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newList = sourceList</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sourceList</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">100</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newList</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">100</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><h2 id="03-is和-x3D-x3D-区别"><a href="#03-is和-x3D-x3D-区别" class="headerlink" title="03.is和&#x3D;&#x3D;区别"></a>03.is和&#x3D;&#x3D;区别</h2><ul><li>is不仅数据一样内存地址也一样</li><li>&#x3D;&#x3D; 只判断数据和数据类型一样即可</li></ul><p><img src="./assets/image-20210118164330925.png" style="width: 300px; margin-left: 20px;"> </img></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
